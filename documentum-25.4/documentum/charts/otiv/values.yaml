# Default values for IV
# This is a YAML-formatted file.
# Declare variables to be passed into your templates.

# if true, chart will attempt to create the primary service account, as defined by
#   .global.ServiceAccountName, that's used by otiv statefulsets and deployments
#   If false, the chart won't create the service account under the assumption that
#   it's being created by a parent chart.
#  In the case this is set to true, the chart won't create the service account if the
#   name is "default" or if it's able to detect that the serivce account already exists
createServiceAccount: true

## k8s secret that stores passwords relevant for the OTIV services; secret needs to be created
#    prior to helm installation.
#   When this is set, it's not necessary to set helm password/secret properties, e.g.:
#      global.masterPassword, global.database.adminPassword, publication.clientSecret, etc.
#   See otiv/example-secret.yaml for example secret yaml
# NOTE: this property just handles otiv passwords/secrets and doesn't support OTDS or the
#    posgresql container secrets; this means that the keys within the otiv/example-secrets.yaml
#    starting with OTDS and postgres aren't relevant, and assumes the database and OTDS will be
#    set up prior the OTIV installation.
existingSecret:

ingress:
  enabled: true

# if OTDS has been configured for multi-tenancy, specifies the relevant tenant id
otdsTenantID:

# specifies the OTDS admin user name; defaults to "admin"
otdsAdminUser:

resourceSecretKey: resource

## Relevant if global.enableOtivCustomizedTruststore is true and global.existingOtivCustomizedCertSecret is not set.
#    Used to specify a single custom certificate to be used by otiv services to communicate to services via SSL.
#    If this property is not set, the chart will look to import certificates from its otiv/certificates directory.
#;   This property can be set via the command line with the --set-file argument: e.g. --set-file singleCaCert=myCert.crt
singleCaCert: |

global:
  ## Enables the import of custom certificates for use by the otiv containers to communicate via SSL to services
  #   whose private certificates aren't signed by a root certificate authority.
  #  Certificates to import must be specified either in a:
  #   * secret referenced in the global.existingOtivCustomizedCertSecret property, or
  #   * via the singleCaCert property, or
  #   * placed in the helm chart's otiv/certificates directory
  enableOtivCustomizedTruststore: false
  ## Relevant if global.enableOtivCustomizedTruststore is true. 
  #    References the name of the k8s secret containing one or more custom truststore certificates.
  #    If blank, chart will attempt to import certificates from singleCaCert or the chart's otiv/certificates directory.
  existingOtivCustomizedCertSecret:
  ## specifies the storage class (ReadWriteOnce) to use for postgresql (non-production) amqp storage
  #  if nothing is specified after &storageClassName, the default storage class for the cluster is used;
  #    specify a value after to change from default, e.g.: storageClassName: &storageClassName trident-nfs
  storageClassName: &storageClassName
  ## specifies the storage class (ReadWriteMany required) to use for IV published artifacts
  #  if no value is specified, the default storage class for the cluster is used
  storageClassNameNFS:
  # size of NFS storage to allocate for IV published artifacts
  nfsPersistenceSize: 2Gi

  ## the public web protocol to access services; valid values are https or http
  publicWebProtocol: &publicWebProtocol https

  # name of the service account associated with the otds and postgresql (non-production) service accounts
  serviceAccountName: &serviceAccountName otiv-sa

  ## database host and user by config, publication, publisher, and markup services
  database:
    ## Valid values are postgresql, oracle, or mssql
    type: postgresql
    hostname: &db_host pg-otiv
    port: &db_port 5432
    ## Database name that psql initially connects with prior to command execution
    adminDatabase: postgres
    adminUsername: &db_user postgres
    # UPDATE REQUIRED; add password after &db_password anchor
    #   if upgrading helm chart, password needs to match that of existing db
    adminPassword: &db_password
    ## Intlligent Viewing application database name
    ivName: &db_name otiv
    # Database application user name and password
    ivUsername: otiv
    ivPassword:

    # set to true if database is configured for SSL communication
    ssl: false
    # if above ssl property is true, the specified ssl mode will be used for PostgreSQL
    #  valid values are (in ascending order of security) -> prefer, require, verify-ca, verify-full
    sslMode: prefer
    #OracleConnectOptions allows users to set options for connecting to an Oracle database and enable ssl
    #oracleConnectOptions: ?param1=value1&param2=value2&oracle.net.ssl_server_dn_match=true&....
    oracleConnectOptions: 

  # set to true if running on a kubernetes cluster configured for ipv6
  ipv6Enabled: false

  # http/https calls to the access source documents are routed through the proxy if the host
  #  and port properties are set, and the url is not specified in the excludes property
  proxy:
    ## proxy hostname or IP. If username/password required, format is username:password@some.proxy.net
    host:
    port: 3128
    # list can be either | or , delimited, i.e.  "10.0.0.0/8|192.168.0.0/16|otds|.company.net"
    # IP and DNS entries to internal k8s services should be included in the excludes list
    excludes: "otds|10.0.0.0/8"

  # the following properties should only be updated if connecting to an external AMQP broker
  #   and not the default rabbitmq container that can be deployed as part of this chart
  # If using this chart's rabbitmq container, the rabbitmq password can be set via the
  #   global.amqp.password property, or a pre-existing password value can be established
  #   by setting assigning it to the rabbitmq-password key in the secret defined by global.existingSecret
  #     or existingSecret
  # If using an external MQ, then the password must be set in the secret defined by global.existingSecret
  #   with the key rabbitmq-password
  amqp:
    ## amqp/rabbitmq properties; used by the publication and publisher services
    host: &amqp_host otiv-amqp
    user: user
    vhost: /
    ssl: false
    # if not set, defaults to 5671 if ssl is true, and 5672 if ssl is false
    port:
    # UPDATE REQUIRED
    password: &amqp_password

    pwdKey: rabbitmq-password

    reconnectAttempts: 5

  ## k8s secret that stores passwords/secrets relevant to the OTIV and OTDS; secret needs to be
  #      created prior to helm installation.
  #   When this is set, it's not necessary to set helm password/secret properties, e.g.:
  #      global.masterPassword, global.database.adminPassword, publication.clientSecret, etc.
  #   See otiv/example-secret.yaml for example secret yaml
  existingSecret: &existing_secret

  ## name of the key within the secret that has the otds password
  otdsSecretKey: ADMIN_USER_PASSWORD

  ## name of the key within the secret that has the db password
  dbSecretKey: OTIV_DB_ADMIN_PASSWORD

  ## name of the key within the secret that has the iv db password
  ivDbSecretKey: OTIV_DB_PASSWORD

  # indicates where the transformation services output is directed, and potentially its format
  # "stdout" directs to starndard output; "stdout_json" diredts to standard output, but output
  #    in in json format.
  logOutput: stdout

  ## hazelcast port
  hazelport: 5701

 # Experimental
  hpa:
    # indicates whether HPA in general is enabled
    enabled: false
    # indicate whehter the cpu and memory targets are set. Can be overridden in the subchart
    cpuTargetEnabled: true
    memoryTargetEnabled: false
    # valid values are averageValue or utilization
    targetType: averageValue

  imageBaseTag: &image_base_tag 25.4.0

  ## the domain name used to construct the ingress URLs
  # UPDATE REQUIRED
  ingressDomainName: example.com

  # determines if the ingress hostname includes the namespace in its name;
  #  set to true if OTIV being deployed to multiple namespaces within a cluster
  ingressIncludeNamespace: true

  # The following fields determine how the publicly accessible IV FQDNs are set
  # * if no value is set, the FQDN is set to: otiv-<service>-<namespace>.<ingressDomainName> where service equals asset, etc.
  #     Note that "-<namespace>" is only included if ingressIncludeNamespace is set to true
  # * if value contains at least one ".", the value represents the full FQDN of the IV service, i.e. <ingressOtivAsset>
  # * if a value is set but doesn't contain a ".", the value represents the first DNS field of the FQDN
  #     which is prepended to ingressDomainName, i.e. <ingressOtivAsset>-<namespace>.<ingressDomainName>
  #     Note that "-<namespace>" is only included if ingressIncludeNamespace is set to true
  ingressOtivAsset:
  ingressOtivHighlight:
  ingressOtivMarkup:
  ingressOtivPublication:
  ingressOtivViewer:

  # Note that recent nginx ingress controllers define an ingress class of "public"
  ingressClass: nginx
  # if ingress is an https end-point, create a secret with certificate and private key and set
  #   the following property with the name of the secret, i.e. ingressSSLSecret: otiv-tls-secrets
  #   Setting a value for this secret prevents the ingress endpoints from receiving http traffic
  ingressSSLSecret:
  ingressAnnotations:
    {}
    # If adding ingressAnnotation, remove braces from above line, and add entries
    #   following the pattern in the following line (removing the leading comment)
    #nginx.ingress.kubernetes.io/affinity: cookie

  ## the default docker registry where the OTIV docker images are stored
  ##   can be overridden by per service by setting <service>.image.source
  # UPDATE REQUIRED
  imageSource:

  ## the default pull policy for images; can be overridden by per service by setting <service>.image.pullPolicy
  imagePullPolicy: Always

  ## name of the secret needed to pull from docker registry
  imagePullSecret:

  ## the url of the OTDS server; if not defined, defaults to otds-<namespace>.<ingressDomainName>
  #      note that '-<namespace>' isn't included if global.ingressIncludeNamespace is false
  otdsPublicUrl:

  ## defaults to the publicWebProtocol; if different, set explicitly i.e. otdsWebProtocol: http
  #   this property is only relevant if otdsPublicUrl has not been set
  otdsWebProtocol: *publicWebProtocol

  ## indicates if otds is accessible via the k8s network; if set to false, global.otdsPublicUrl is used
  otdsInCluster: true

  ## the k8s url that OTDS is accessible at; only relevant if otdsInCluster is set to true
  ## if property is not set, defaults to the otds service name for the cluster
  otdsPrivateUrl:

  ## The OTDS admin password
  # UPDATE REQUIRED
  #   if upgrading helm chart, password needs to match the currently deployed OTDS admin password
  masterPassword:

  # number of minutes viewer, highlight, and markup services will wait before updating cert from OTDS
  otdsCertUpdateInterval: 1440

  # if there's a need to redeploy ALL otiv containers, modify the following value before running a helm upgrade
  counter: 1

  # the resource name associated with the IV license; defaults to 'iv' if not set
  resourceName:

  # if set to true, information in the request's Forwarded header will be used when
  #  setting the externally accessible URLs
  enableForwarding: false

  # If set to true, Forwarded/X-Forwarded-Host header whitelist enforcement is enabled
  #   and the services validate that the Forwarded/X-Forwarded-* headers adhere to what's
  #   allowed by the forwardedHostsList or forwardedHostsRegex properties.
  #
  # If set to true and the forwardedHostsList and forwardedHostsRegex are not defined
  #    or have been defined with an invalid syntax, the services will fail to start.
  # If both of these properties are configured, forwardedHostsRegex takes precedence.
  # The Forwarded/X-Forwarded-Host headers in incoming requests that do not match the
  #    properties whitelist criteria are ignored.
  # If these properties are defined at the service level (i.e. publication.forwardedHostsList),
  #   the service level definition takes precedence
  enforceForwardedHosts: false

  # a comma-separated list of FQDNs (cannot specify protocols such as https) that are used
  #   for validating the Forwarded/X-Forwarded-* headers.
  forwardedHostsList:

  # a regex pattern to match FQDNs
  # The metacharacter * is a modifier and matches the preceding character 0 or more times;
  #  so * needs to be after another character; typically this will be the metacharacter . (dot)
  #  which represents any single character, e.g.: .*site.sample.*
  forwardedHostsRegex:

  # If set to true, requests will be only be accepted from the servers listed in corsOriginsList
  #  or corsOriginsRegex; if both are defined, corsOriginRegex has precedence
  # If these properties are defined at service level (i.e. publication.corsOriginList),
  #   the service level definition takes precedence
  enforceCorsOrigins: false

  # a comma-separated list of servers that OTIV services will allow origin requests from
  # each origin should start with https:// or http://
  corsOriginsList:

  # a regex pattern for servers that OTIV services will allow origin requests from
  # The metacharacter * is a modifier and matches the preceding character 0 or more times;
  #  so * needs to be after another character; typically this will be the metacharacter . (dot)
  #  which represents any single character. The expression needs to match a url that can begin
  #  with http. An example value would be: .*site.sample.*
  corsOriginsRegex:

  # List of additional custom http headers, comma-separated, that will be allowed by IV services
  customHttpHeaders:

  secretlink:
    enabled: false
    loglevel: INFO
    image:
      name: secretlink
      source:
      tag: latest
    vault:
      ## provide vault server address e.g https://vaultserver:port/
      address:
      ## provide vault secret mount path e.g  kv
      mountpoint:
      ## vault secret path e.g dev/foo
      path:
      ## vault namespace e.g default
      namespace:
      ## vault authentication path to verify authentication. e.g auth/k8s
      authpath:
      ## vault role name
      role:

  # Enabling this creates a k8s secret named otiv-spc-secrets which will be used by the otiv services to
  #  retrieve relevant credential information. The k8s secret is created using the SecretProviderClass
  #  based off of secrets store csi driver. Secrets are pulled by the driver from the relevant hyperscaler's
  #  secrets manager; just AWS is currently supportted.
  # NOTE: if a parent chart already creates a single k8s secret that has all required otiv secret keys,
  #   there's no need to enable this functionality. Instead the global.existingSecret or otiv's existingSecret
  #   property can be set to the name of this k8s secret. The IV services expect the following secrets to be set:
  #   * OTDS master password - default key -> ADMIN_USER_PASSWORD
  #   * DB password - default key -> OTIV_DB_ADMIN_PASSWORD
  #   * AMQP/rabbitmq password - default key -> rabbitmq-password
  #   * Publication OAuth secret - default key -> OTIV_PUBLICATION_CLIENT_SECRET
  #   * Monitoring OAuth secret - default key -> OTIV_MONITOR_CLIENT_SECRET
  #   * Publisher OAuth secret - default key -> OTIV_PUBLISHER_CLIENT_SECRET
  #   * Highlight OAuth secret - default key -> OTIV_HIGHLIGHT_CLIENT_SECRET
  otivSecretProviderClass:
    enabled: false
    ## optional property if Secrets Provider is aws; setting this can have a slight performance benefit
    region: 
    ## Vault provider; currently only "aws" is supported
    provider: aws
    ## For EKS, by default authentication to secrets manager happens via IAM Roles for Service Accounts (IRSA).
    #    If property usePodIdentity is set to true, then Pod Identities is instead used for authentication.
    usePodIdentity: false
    ## AWS IAM role arn that allows access to relevant secrets in AWS secrets manager. This value is added as
    #   an annotation to the service account used by the otiv services.
    saRole: 

    ## AWS arn of the secrets manager secret that stores the IV credentials
    #   If not set, then dbObjectName, otdsObjectName, and ivObjectName must all be set
    objectName:

    ## AWS arn of the secrets manager secret that stores the database password.
    #   If not set, retrieval of the db password uses the arn defined in objectName
    dbObjectName:
    # Name of the secret's db admin password key; defaults to OTIV_DB_ADMIN_PASSWORD
    dbKey:
    # Name of the secret's db otiv application password key; defaults to OTIV_DB_PASSWORD
    ivDbKey:

    ## AWS arn of the secrets manager secret that stores the OTDS admin password.
    #   If not set, retrieval of the OTDS password uses the arn defined in objectName
    otdsObjectName:
    # Name of the secret's otds admin password key; defaults to ADMIN_USER_PASSWORD
    otdsKey:
    ## AWS arn of the secrets manager secret that stores the amqp/rabbitmq password and the IV UAuth secrets
    #   If not set, retrieval of the these IV passwords/secrets uses the arn defined in objectName
    ivObjectName:
    # Name of the secret's rabbitmq password key; defaults to rabbitmq-password
    amqpKey:
    # Name of the secret's publication oauth secret key; defaults to OTIV_PUBLICATION_CLIENT_SECRET
    publicationKey:
    # Name of the secret's monitoring oauth secret key; defaults to OTIV_MONITOR_CLIENT_SECRET
    monitoringKey:
    # Name of the secret's publisher oauth secret key; defaults to OTIV_PUBLISHER_CLIENT_SECRET
    publisherKey:
      # Name of the secret's highlight oauth secret key; defaults to OTIV_HIGHLIGHT_CLIENT_SECRET:
    highlightKey:

  # Enabling this mounts certificats defined in the otiv certificates SecretProviderClass to the otiv containers
  #  /tmp/certs directory which are imported to the otiv containers trust store.
  # NOTE: if a parent chart already creates a single k8s secret that has all trust certificates, this
  #  functionality does not need to be enabled. Instead the global.enableOtivCustomizedTruststore property
  #  can be set to the name of this secret.
  otivSecretProviderClassCerts:
    enabled: false
    ## optional property if Secrets Provider is aws; setting this can have a slight performance benefit
    region: 
    ## Vault provider; currently only "aws" is supported
    provider: aws
    ## AWS IAM role arn that allows access to relevant secrets in AWS secrets manager. This value is added as
    #   an annotation to the service account used by the otiv services.
    #  Note that if both global.otivSecretProviderClass and global.otivSecretProviderClassCerts are enabled,
    #  the global.otivSecretProviderClassCerts.saRole value is used for the service account annotation
    saRole: 

    ## AWS arns of the secrets manager certificate secrets to be added to the IV containers trust stores
    #  NOTE: that the certificate should not be stored as a value within the AWS secrets manager secret's json structure. 
    #    For instance, a pem certificate's contents should just be pasted into the plaintext editor when using AWS console.
    #  Format is:
    #  - name: "arn:aws:secretsmanager:<region>:<certificate1>"
    #    certFileName: <secret.pem>  # must have a .pem or .crt file extension
    #  - name: "arn:aws:secretsmanager:<region>:<certificate2>"
    #    certFileName: <secret.pem>  # must have a .pem or .crt file extension
    #  ...
    secrets:

  newRelic:
    # new relic license key
    licenseKey:

    # new relic base app name
    # Each service appends its service name to the new relic app name
    # if empty, defaults to global.ingressDomainName
    baseAppName:

    # new relic proxy host
    host:

    # new relic proxy port
    port: 3128

  # adds listed annotations to all otiv services
  # each entry needs to be a single string that contains a colon ( : ) that separates
  #   the property name and value
  service:
    annotations: []

  # Should be set to true if using a service mesh like istio which uses envy sidecar
  #    containers; this technology doesn't allow communication from init containers
  # if false, init containers are used to perform database and OTDS initialization
  # if true, jobs are used to do this initialization. Service pods will generally
  #   restart several times before successfully getting to a ready state
  usingServiceMesh: false

  # Should be set to true if using istio's VirtualServices for ingress. Setting this to true
  #  instantiates an istio VirtualService object for each otiv service that is externally facing
  #  Generally, when this is set, ingress is also disabled within the cluster, which is done
  #   by setting ingressEnabled=false
  istioVirtualServicesEnabled: false

  # The range of IPs for the k8s API server. Used when istio sidecars are used and may
  #   be blocking communication to the kubernetes API.
  k8sApiIPRanges: 10.0.0.0/32,172.0.0.0/32

  # The range of IPs for the transformation services. Required so that IP communication
  #   within these services can occur in istio's PeerAuthentication strict mode.
  transformationPodApiIPRanges: 10.0.0.0/32

  # During upgrade to OTDS versions 23.4 or 24.1, it's possible for an extra otds-api user
  #  to be created, which causes issues for the ability of the IV services to retrieve OAuth
  #  tokens. Setting the following property to true, will stop the OTDS service prior to
  #  upgrade if the currently running version is earlier than 23.4.
  stopLegacyOtdsForUpgrade: false

  # time zone that the containers are set to (sets TZ env var). If not set,
  #   containers will use UTC. Values should be set to a "TZ database name"
  #   from https://en.wikipedia.org/wiki/List_of_tz_database_time_zones
  # If an invalid value is entered, the time zone defaults to UTC
  timeZone: Etc/UTC

  # This field has three acceptable settings: "DoNotSchedule", "ScheduleAnyway", or it can be blank.
  #   If set to either DoNotSchedule or ScheduleAnyway, the deployment definitions will include a
  #   topologySpreadConstraints definition with a mexSkew set to 1 for two different topology keys,
  #   and their whenUnsatisfiable property set to the value specified (either DoNotSchedule or ScheduleAnyway).
  #   If topologyScheduling is set to blank or "", the topologySpreadConstraints is not included in the deployments
  topologyScheduling:

  # Sets the terminationGracePeriodSeconds property in the transformation service pods
  transformationTerminantionGracePeriod:

  # RWX access is required for transformation pods to have write acccess to the cache PVC across nodes
  #   Following property can be set to true for testing purposes on systems without a RWX storage class
  transformationPvcRWO: false

  # These properties take a comma delimited set of origins, i.e. http(s)://<hostname><:port>
  #   where source files to be converted are allowed to be retrieved from.
  # If neither trustedSourceOrigins nor trustedSourceOriginsAnonymous is set, then there is
  #   no origin restriction and IV attempts to retrieve source files from the requested
  #   file url; however, if the file url is at an http endpoint (as opposed to https), no
  #   Authorization header is sent with the request.
  # If either property is defined, then retrievals are restricted to the defined origins.
  # Origins defined in trustedSourceOrigins will pass along an Authorization header,
  #   whereas origins defined in trustedSourceOriginsAnonymous won't include an
  #   Authorization header. The same origin should not be listed in both properties.
  trustedSourceOrigins:
  trustedSourceOriginsAnonymous:

  otdsUseReleaseName: false
  otdsServiceName: otds

  ## List additional pod labels for all otiv pods
  ## eg:
  ## otivPodLabels:
  ##   app.kubernetes.io/app_name: otiv
  otivPodLabels: {}


# container properties relevant to chart initialization pods
initialization:
  image:
    name: otiv-config
    source:
    tag: *image_base_tag

amqp:
  enabled: true
  image:
    name: otiv-amqp
    tag: *image_base_tag

  ## String to fully override amqp.fullname template
  ## This value needs to match global.amqp.host in this chart
  fullnameOverride: *amqp_host

  persistence:
    size: 1Gi
    storageClass: *storageClassName

  ## Uncomment following yaml block if wanting to set extra configuration for rabbitmq
  #rabbitmq:
    # define configuration for rabbitmq;
    #extraConfiguration: |-
      #consumer_timeout=10800000   # 3 hours; default is 2 hours

  ## List additional pod labels for amqp pods
  ## eg:
  ## podLabels:
  ##   app.kubernetes.io/app_name: amqp
  podLabels: {}

## The following properties are for the sub-charts.
#   Note that the *.image.tag properties refer to "latest"
#   It's recommended that the when installing/upgrading this helm chart
#   that either the following tags are updated with a specific version, or
#   that a yaml file with the specific versions is provided as a -f parameter
#   to the helm install/upgrade command.  The latestTags.yaml which has specific
#   versions is distributed along with this helm chart. Using specific versions
#   provides clarity on the version being used, and can avoid issues with a
#   docker registry server that may be providing an older cached version of
#   the "latest"

## publication service settings
publication:
  enabled: true

  image:
    tag: *image_base_tag

  service:
    port: &publication_port 80
  # potential loglevel values: ERROR, WARN, INFO, DEBUG, TRACE
  loglevel:
    example: DEBUG
    #access: DEBUG
    #expiry: DEBUG
    #hazelCast: ERROR
    #migrator: DEBUG
    #netty: DEBUG
    #service: DEBUG
    #spi: DEBUG
    #spiAjira: DEBUG
    #spiMkondo: DEBUG
    #spiSoteria: DEBUG
    #spiPithos: DEBUG
    #system: DEBUG
    #util: DEBUG
    #vertx: DEBUG
    #vertxHost: DEBUG

  # if set to true, requests will be only be accepted from the servers listed in corsOriginsList
  #  or corsOriginsRegex; if both are defined, corsOriginRegex has precedence
  # If not defined here, corresponding global property values are used
  #enforceCorsOrigins: false

  # a comma-separated list of servers that OTIV services will allow origin requests from
  # each origin should start with https:// or http://
  #corsOriginsList:

  # a regex pattern for servers that OTIV services will allow origin requests from
  # The metacharacter * is a modifier and matches the preceding character 0 or more times;
  #  so * needs to be after another character; typically this will be the metacharacter . (dot)
  #  which represents any single character. The expression needs to match a url that can begin
  #  with http. An example value would be: .*site.sample.*
  #corsOriginsRegex:

  # number of seconds the publication service waits for a HEAD response for
  #  accessing the source document; may want to increase for slow connections
  accessCheckTimeoutSeconds: 3

  ## List additional pod labels for publication pods
  ## eg:
  ## podLabels:
  ##   app.kubernetes.io/app_name: publication
  podLabels: {}

  clientId: iv-publication
  clientSecret:

  monitoring:
    clientId: iv-monitoring
    clientSecret:

## asset service settings
asset:
  enabled: true

  image:
    tag: *image_base_tag

  # potential loglevel values: ERROR, WARN, INFO, DEBUG, TRACE
  loglevel:
    example: DEBUG
    #artifacts: DEBUG
    #hazelCast: DEBUG
    #netty: DEBUG
    #system: DEBUG
    #vertx: DEBUG
    #vertxWebHandler: DEBUG

  # if set to true, requests will be only be accepted from the servers listed in corsOriginsList
  #  or corsOriginsRegex; if both are defined, corsOriginRegex has precedence
  # If not defined here, corresponding global property values are used
  #enforceCorsOrigins: false

  # a comma-separated list of servers that OTIV services will allow origin requests from
  # each origin should start with https:// or http://
  #corsOriginsList:

  # a regex pattern for servers that OTIV services will allow origin requests from
  # The metacharacter * is a modifier and matches the preceding character 0 or more times;
  #  so * needs to be after another character; typically this will be the metacharacter . (dot)
  #  which represents any single character. The expression needs to match a url that can begin
  #  with http. An example value would be: .*site.sample.*
  #corsOriginsRegex:

  publication:
    port: *publication_port

  ## List additional pod labels for asset pods
  ## eg:
  ## podLabels:
  ##   app.kubernetes.io/app_name: asset
  podLabels: {}

## highlight service settings
highlight:
  enabled: true

  image:
    tag: *image_base_tag

  # error, warn, info, debug
  loglevel: info
  # fatal, error, warn, info, debug, trace
  newRelic:
    loglevel: debug

  # if set to true, requests will be only be accepted from the servers listed in corsOriginsList
  #  or corsOriginsRegex; if both are defined, corsOriginRegex has precedence
  # If not defined here, corresponding global property values are used
  #enforceCorsOrigins: false

  # a comma-separated list of servers that OTIV services will allow origin requests from
  # each origin should start with https:// or http://
  #corsOriginsList:

  # a regex pattern for servers that OTIV services will allow origin requests from
  # The metacharacter * is a modifier and matches the preceding character 0 or more times;
  #  so * needs to be after another character; typically this will be the metacharacter . (dot)
  #  which represents any single character. The expression needs to match a url that can begin
  #  with http. An example value would be: .*site.sample.*
  #corsOriginsRegex:

  # If set, the NODE_OPTIONS env variable will be set with the value
  nodeOptions:

  publication:
    port: *publication_port

  ## List additional pod labels for highlight pods
  ## eg:
  ## podLabels:
  ##   app.kubernetes.io/app_name: highlight
  podLabels: {}

  clientId: iv-highlight
  clientSecret:

## markup service settings
markup:
  enabled: true

  image:
    tag: *image_base_tag

  # error, warn, info, debug
  loglevel: info

  # fatal, error, warn, info, debug, trace
  newRelic:
    loglevel: debug

  # The maximum number of SQL connections in the markup service pool; value must be greater than 0
  dbMaxPoolSize: 10

  # if set to true, requests will be only be accepted from the servers listed in corsOriginsList
  #  or corsOriginsRegex; if both are defined, corsOriginRegex has precedence
  # If not defined here, corresponding global property values are used
  #enforceCorsOrigins: false

  # a comma-separated list of servers that OTIV services will allow origin requests from
  # each origin should start with https:// or http://
  #corsOriginsList:

  # a regex pattern for servers that OTIV services will allow origin requests from
  # The metacharacter * is a modifier and matches the preceding character 0 or more times;
  #  so * needs to be after another character; typically this will be the metacharacter . (dot)
  #  which represents any single character. The expression needs to match a url that can begin
  #  with http. An example value would be: .*site.sample.*
  #corsOriginsRegex:

  # If set, the NODE_OPTIONS env variable will be set with the value
  nodeOptions:

  service:
    port: &markup_port 80

  # If true, requires an integrator provided JWT to authorize access to markups
  enableRoleBasedAccessControl: false

  # string used for generating a key to sign access control JWT
  jwtSecret:

  ## List additional pod labels for markup pods
  ## eg:
  ## podLabels:
  ##   app.kubernetes.io/app_name: markup
  podLabels: {}

## viewer service settings
viewer:
  enabled: true

  image:
    tag: *image_base_tag

  # error, warn, info, debug
  loglevel: info
  # fatal, error, warn, info, debug, trace
  newRelic:
    loglevel: debug

  # if set to true, requests will be only be accepted from the servers listed in corsOriginsList
  #  or corsOriginsRegex; if both are defined, corsOriginRegex has precedence
  #enforceCorsOrigins: false

  # a comma-separated list of servers that OTIV services will allow origin requests from
  # each origin should start with https:// or http://
  #corsOriginsList:

  # a regex pattern for servers that OTIV services will allow origin requests from
  # The metacharacter * is a modifier and matches the preceding character 0 or more times;
  #  so * needs to be after another character; typically this will be the metacharacter . (dot)
  #  which represents any single character. The expression needs to match a url that can begin
  #  with http. An example value would be: .*site.sample.*
  #corsOriginsRegex:

  # If set, the NODE_OPTIONS env variable will be set with the value
  nodeOptions:

  ## List additional pod labels for viewer pods
  ## eg:
  ## podLabels:
  ##   app.kubernetes.io/app_name: viewer
  podLabels: {}

## publisher settings
publisher:
  enabled: true

  image:
    tag: *image_base_tag

  markup:
    port: *markup_port

  # Adds entries to the publisher's /etc/hsots file. For more info, see:
  #   https://kubernetes.io/docs/tasks/network/customize-hosts-file-for-pods/
  #hostAliases:
  #- ip: "127.0.0.1"
  #  hostnames:
  #  - "foo.local"
  #  - "bar.local"

  # set to true to add write_any_markups scope to the iv-publisher OAuth client
  #   this enables the publishing agent to create or update markups
  writeMarkups: false

  # potential loglevel values: ERROR, WARN, INFO, DEBUG, TRACE
  loglevel:
    example: DEBUG
    #artifacts: DEBUG
    #config: DEBUG
    #conversion: DEBUG
    #converter: DEBUG
    #converterHost: DEBUG
    #discovery: DEBUG
    #metrics: DEBUG
    #netty: DEBUG
    #retrieval: DEBUG
    #sequencing: DEBUG
    #spi: DEBUG
    #spiAjira: DEBUG
    #spiMkondo: DEBUG
    #spiPithos: DEBUG
    #spiSoteria: DEBUG
    #system: DEBUG
    #util: DEBUG
    #vertx: DEBUG
    #zmq: DEBUG

  ## List additional pod labels for publisher pods
  ## eg:
  ## podLabels:
  ##   app.kubernetes.io/app_name: publisher
  podLabels: {}

  ## set to true if needed to convert Office documents on FIPS compliant hardware
  fipsEnabled: false

  clientId: iv-publisher
  clientSecret:

## config service settings
config:
  enabled: true

  image:
    tag: *image_base_tag

  # potential loglevel values: ERROR, WARN, INFO, DEBUG, TRACE
  loglevel:
    example: DEBUG
    #hazelCast: ERROR
    #migrator: DEBUG
    #netty: DEBUG
    #service: DEBUG
    #spi: DEBUG
    #spiSoteria: DEBUG
    #spiPithos: DEBUG
    #system: DEBUG
    #util: DEBUG
    #vertx: DEBUG

  ## List additional pod labels for config pods
  ## eg:
  ## podLabels:
  ##   app.kubernetes.io/app_name: config
  podLabels: {}

  # Disables the shutdown scripts in the transfornmation pods from being invoked when
  #   a termination signal is received
  ivShutdownDisabled: false

otds:
  enabled: true

  ingress:
    enabled: false

  otdsws:
    ingress:
      enabled: false
    ## image.* defines Docker image location, tags and pull parameters for
    ## OTDS - you need to adjust this:
    image:
      ## the docker registry to retrieve the otds image from
      name: otds-server
      tag: 25.3.0

    ## cryptKey is used for secure synchronized access to OpenDJ from frontend instances
    ## The value is a 16 character ASCII string that has been base64 encoded
    # UPDATE REQUIRED
    cryptKey:

    ## otdsdb.* defines the connection information for the DB which is the
    ## backend data storage location for OTDS
    otdsdb:
      ## url specified the url used to connect to the DB for OTDS
      ## The following is a list of sample values.
      ## jdbc:postgresql://postgres.domain.local:5432/otdsdb
      ## jdbc:sqlserver://ms-sql.domain.local:1433;databaseName=otdsdb
      ## jdbc:oracle:thin:@oracle.domain.local:1521:otdsdb
      ## jdbc:sap://hana.domain.local:30015/?databaseName=otdsdb
      ## if blank, a url is constructed
      url:
      ## database name
      name: otdsdb
      ## username specifies the account for the DB connection
      username: otds
      ## password specifies the password for the DB account
      ## UPDATE REQUIRED
      password:
      ## automaticDatabaseCreation can be used to automatically create the specified database if it does not exist.
      ## This is OPTIONAL! Typically the database is pre-created by IAC or otherwise by a system administrator.
      ## This feature is currently only supported with PostgreSQL and Oracle
      automaticDatabaseCreation:
        enabled: true

postgresql:
  ## whether postgresql is to be installed
  enabled: true

  ## Bitnami PostgreSQL image version
  ## ref: https://hub.docker.com/r/bitnami/postgresql/tags/
  image:
    ## UPDATE REQUIRED IF docker.io not accessible
    registry:
    repository: bitnami/postgresql
    tag: 15.4.0

  ## String to fully override postgresql.fullname template
  ## This value needs to match global.database.hostname in the brava chart
  fullnameOverride: *db_host

  ## volumePermissions: Change the owner of the persist volume mountpoint to RunAsUser:fsGroup

  service:
    ## PosgresSQL service type
    type: ClusterIP
    port: *db_port

 #primary:
 #  resources:
 #    limits:
 #      cpu: 0.5
 #      memory: 512Mi
 #  persistence:
 #    storageClass: *storageClassName
 #    size: 2Gi

  auth:
    ## @param auth.postgresPassword Password for the "postgres" admin user
    postgresPassword: *db_password

    ## @param auth.username Name for a custom user to create
    username: *db_user
    ## @param auth.password Password for the custom user to create
    password: *db_password
    ## @param auth.database Name for a custom database to create
    database: *db_name

    # PostgreSQL password using existing secret
    existingSecret: *existing_secret

  serviceAccount:
    ## @param serviceAccount.create Enable creation of ServiceAccount for PostgreSQL pod
    create: false
